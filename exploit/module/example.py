# -*- coding:utf-8 -*- 
#!/usr/bin/env python3
#Description: wukong exploit 
#Author:      Bing
#Email:       amzing_bing@outlook.com
#DateTime:    2017-05-10 23:08:39

import sys
sys.path.append("../../")

import gevent, os, re, requests
from gevent.pool import Pool
from gevent import monkey; monkey.patch_all()
from core.settings import DICT_PATH
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


def custom_gevent(func, fuzzing) :
	'''
	自定义多协程 -- finish
	'''
	pool = Pool(200)
	for text in fuzzing :
		pool.add( gevent.spawn(func, text) )
	pool.join() 


class WKLevel(object):
	'''
	危害等级
	'''
	high = 'high'
	medium = 'medium'
	low = 'low'
	normal = 'normal'


class WKType(object):
	'''
	漏洞类型
	'''
	ssrf = '服务器端请求伪造'
	injection = '注入'
	xss = 'xss跨站脚本攻击'
	xxe = 'xml外部实体攻击'
	file_upload = '任意文件上传'
	file_operation = '任意文件操作'
	file_traversal = '目录遍历'
	rce = '远程命令/代码执行'
	lfi = '本地文件包含'
	rfi = '远程文件包含'
	info_leak = '信息泄漏'
	misconfiguration = '错误配置'
	android = '安卓移动端'
	ios = 'IOS设备'
	network = '网络设备'
	other = '其它'


class WKExploit(object):
	level = WKLevel()
	category = WKType()

	def __init__(self) :
		'''
		漏洞信息和测试参数
		'''
		self.info = {
			# 输入参数
			"protorl" : "http://",
			"host" : "",	
			"port" : "",
			"cookie" : "wukong",
			"fuzzing" : [],#local/api[user_pwd,poc_dict,finger_dict,post_text,get_text]
		}
		self.result = {
			# 结果信息
			"status" : False,
			"data" : [{
				"bug_name" : "",
				"bug_author" : "Bing",
				"bug_level" : self.level.normal,
				"bug_type" : self.category.other,
				"bug_ref" : "",
				"bug_desc" : "",
				"bug_result" : [],
				"bug_repair" : ""
			}],
		}


	def parameter(self, types, default) :
		'''
		设置默认参数
		'''
		poc = ""
		if types == "" :
			poc = default                        
		else:
			poc = types
		return poc


	def check(self, txt):
		'''
		漏洞验证
		'''
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		sock.settimeout(2)
		host = self.info["host"]
		address = (host, txt)

		try:
			sock.connect(address)
			sock.send("OPTION ／ HTTP 1.1\r\n".encode())
			buffers = sock.recv(256)
			self.result["status"] = True
			result = "{'port' : '%s','finger' : '%s' }" % (txt, buffers.__str__())
			self.result["data"][0]["bug_result"].append(result)
		except:
			sock.close()
		sock.close()


	def exploit(self):
		'''
		自定义多协程
		'''
		fuzzing = self.info["fuzzing"]
		if len(fuzzing) > 0 :
			custom_gevent(self.check, fuzzing)
		else:
			self.check("")


	def custom_fuzzing_api(self, types, name):
		'''
		获取fuzzing数据接口

		# webapi
		parameter 
			{"type" : "brute","name" : "redis/mysql"}
			{"type" : "finger","name" : "http/port"}
			{"type" : "sqlmap","name" : ""}
		return 
			{"status": 1,"data" : ['pwd']}
			{"status": 1,"data" : ['user|pwd']}
			{"status": 1,"data" : [finger1,finger2]}
			{"status": 1,"data" : [post_text]}
		'''
		try:
			requests.post(url = "12743", data = "", cookies = "")
			#待编写
			return []
		except:
			subprefix = []
			dict_files = os.listdir(DICT_PATH)
			poc_dict_regex = re.compile('^('+ types +'-).*?' + name + '.*?\.txt$')

			for filename in dict_files :
				match = poc_dict_regex.search(filename) 
				if match :
					filename_path = os.path.join(DICT_PATH, filename) 
					with open(filename_path,"r") as server:
						for finger in server.readlines():
							subprefix.append(finger.strip())

			dict_list = {}.fromkeys(subprefix).keys()
			return dict_list
